# 2장. TCP/IP의 데이터를 전기 신호로 만들어 보낸다.
## 프로토콜 스택과 LAN 어댑터의 탐험

## 탐험 여행 경유지
```text
1. 소켓을 작성한다.
2. 서버에 접속한다.
3. 데이터를 송/수신한다.
4. 서버에서 연결을 끊어 소켓을 말소한다.
5. IP와 이더넷의 패킷 송/수신 동작
6. UDP 프로토콜을 이용한 송/수신 동작
```

## 구성
전체적인 구성은 **애플리케이션**, **OS**, **드라이버** **소프트웨어**, **하드웨어로** 구성되어 있습니다.

* 애플리케이션
    * 네트워크 애플리케이션
    * Socket 라이브러리 
        * 리졸버
* OS 
    * 프로토콜 스택
        * TCP - 브라우저나 메일등 일반적인 애플리케이션
        * UDP - DNS 서버에 대한 조회 등 짧은 제어용 데이터 송/수신
        * IP - 패킷(데이터를 작게 나눈 덩어리) 을 운반하는게 주 역할
            * ICMP - 패킷을 운반할 때 발생하는 오류를 통지
            * ARP - MAC 주소 조사
* 드라이버 소프트웨어
    * LAN 드라이버
* 하드웨어
    * LAN 어댑터

## 1.소켓을 만든다.
### 프로토콜 스택
OS 내부의 프로토콜 스택에 대해 알아보겠습니다.

프로토콜 스택
* TCP - 브라우저나 메일등 일반적인 애플리케이션
* UDP - DNS 서버에 대한 조회 등 짧은 제어용 데이터 송/수신
* IP - 패킷(데이터를 작게 나눈 덩어리) 을 운반하는게 주 역할
    * ICMP - 패킷을 운반할 때 발생하는 오류를 통지
    * ARP - MAC 주소 조사


### 소켓의 실체는 통신 제어용 제어 정보
**소켓**
* 소켓의 실체 프로토콜 스택은 통신 상대의 IP 주소, 포트 번호 등 여러 가지 제어 정보를  **메모리 영역**에 기록합니다.
* 프로토콜 스택은 이 제어정보를 참조하여 다음에 무엇을 해야할지 판단하는데, 이것이 **소켓의 역할**입니다.

우리는 직접 소켓의 생김새를 확인해볼 수 있는 방법이 있습니다.

<img width="777" alt="194748633-2be98415-8a4d-4cef-bbf8-8873c6fb66c7" src="https://user-images.githubusercontent.com/82758364/194748929-ac879cfc-4c7d-48bf-8ba3-f8c04b6ab731.png">
위에 보이는 것처럼 명령창에 **netstat**을 쳤을 때 보이는 행들이 하나의 소켓에 해당합니다.

소켓을 만든다는 동작은 여기에 새로 한 행의 제어 정보를 추가하고 통신을 준비하는 작업입니다.

### Socket을 호출했을 때 동작
브라우저가 socket이나 connect라는 Socket 라이브러리의 프로그램을 호출하였을 때 프로토콜 스택의 내부가 어떻게 움직이는지 살펴보겠습니다.
- 어플리케이션이 socket을 호출하여 소켓 생성을 의뢰하면, 프로토콜 스택은 한 개의 소켓을 만든다.
- 프로토콜 스택은 소켓 한 개 분량의 메모리 영역을 확보하고 초기 상태라는 것을 기록한다.
- 소켓을 만들면 해당 소켓을 가르키는 **디스크립터**를 어플리케이션에게 알려주며, 디스크립터는 프로토콜 스택 내부의 많은 소켓 중 본인의 소켓 정보를 찾을 수 있는 번호표 같은 정보이다.


## 2. 서버에 접속한다
### 접속의 의미
* 소켓을 만들면 애플리케이션은 connect를 호출하고, 프로토콜 스택은 자기쪽의 소켓을 서버측 소켓에 접속합니다.
* 이더넷이나 통신 회선 등의 케이블은 항상 연결되어 있어 언제나 신호를 보낼 수 있기에 데이터를 신호로 변환하여 송신하기만 하면 언제든지 통신이 가능합니다.
* 하지만, 소켓을 만든 직후 애플리케이션에서 데이터 송신 의로가 오면 프로토콜 스택은 ..?
    * 소켓을 만든 직후에는 아무것도 기록되어 있지 않아 통신 상태를 알 수 없습니다.
    * 서버의 IP주소나 포트 번호를 프로토콜 스택에 알리는 행위가 필요하고, 이 행위 역시 접속 단계에서 하나의 역할입니다.
* 접속 동작의 첫 번째 동작은 통신 상대와 제어 정보를 주고받아 소켓에 필요한 정보를 기록하고 데이터 송수신이 가능한 상태로 만드는 것입니다.
* 데이터 송수신 동작을 실행할 때 데이터를 일시적으로 저장하는 메모리 영역을 **버퍼 메모리**라 부르고 버퍼 메모리를 확보하는 행위 또한 접속 동작에 포함됩니다.


### 맨 앞부분에 제어 정보를 기록한 헤더를 배치한다
| 헤더의 형태로 이러한 제어 정보를 주고 받고 있으며 제어 정보에는 크게 두 가지가 있습니다.

첫 번째는 클라이언트와 **서버가 서로 연락**을 절충하기 위해 주고받는 제어 정보입니다. (헤더에 기입되는 정보)
- 접속 동작 단계에서는 아직 데이터 송수신이 이루어지지 않으므로 데이터를 제외한 제어 정보만으로 패킷이 이루어집니다. 이러한 헤더는 IP, 이더넷, TCP 앞부분에 배치되므로 각각을 잘 알 수 있도록 써야합니다.

두 번째는 소켓에 기록하여 프로토콜 스택의 **동작을 제어**하기 위한 정보입니다. (소켓에 기록되는 정보)
- 여기에는 애플리케이션에서 통지된 정보, 통신 상대로부터 받은 정보 등이 수시로 기록되며 이는 프로토콜 스택의 프로그램과 일체화되어 있으며 프로토콜 스택이 어떤 정보를 필요로 하는지는 프로토콜 스택을 만드는 사람에 따라 달라집니다.

이러한 소켓에 기록한 제어 정보는 상대측에서 볼 수 없습니다. 또한, 윈도우와 리눅스라는 OS는 프로토콜 스택을 만드는 방법이 다르므로 필요한 제어 정보도 다릅니다. 하지만 양자가 문제 없이 통신할 수 있는 것은 어떠한 프로토콜(규칙)에 따르고 있기 때문입니다.

### 접속 동장의 실제
Socket 라이브러리의 connect를 호출하는 곳부터 시작됩니다.
```java
connect(<디스크립터>, <서버측의 IP주소와 포트번호>, ......)
```

> 대화 과정
> 1. 데이터 송수신 동작의 개시를 나타내는 제어 정보를 기록한 TCP 헤더를 만든다.
     >   - 송신처와 수신처의 포트 번호로 접속하는 소켓을 지정한다.
> 2. TCP 헤더를 IP 담당 부분에 건네어 송신을 의뢰한다.
> 3. IP 담당 부분이 패킷 송신을 실행하고 패킷이 서버에 도착하면 서버측 IP 담당 부분이 TCP 담당 부분에게 건넨다.
> 4. 서버측 TCP 담당 부분이 TCP 헤더를 조사하여 기록된 수신처 포트 번호에 해당하는 소켓을 찾는다.
> 5. 해당되는 소켓을 발견하면 필요한 정보를 기록하고 접속 동작을 진행중 상태로 변경한다.
> 6. 위 과정이 끝나면 서버의 TCP 담당 부분은 응답을 돌려보낸다.
     >    - 응답을 보낼 때 패킷을 받은 것을 알리기 위해 ACK 컨트롤 비트를 1로 만든다.


이로써 소켓은 데이터를 송수신할 수 있는 상태가 됩니다. 이 때 파이프와 같은 것으로 소켓이 연결되었다고 생각할 수 있습니다. 이 파이프와 같은 것을 **커넥션** 이라고 합니다. 또한 커넥션은 _close_ 를 호출하여 연결을 끊을 때까지 존재합니다.


## Q. TCP를 사용하여 클라이언트 요청이 끝났는 지 어떻게 알고 close 를 호출할까요?
### A. 보통의 서버는 클라이언트 요청에서 EOP일 때까지 데이터를 받게 되고 EOP를 받게 되면 서버는 요청을 완전히 받았다는 것으로 인지합니다. 그리고나서 소켓하는 close를 호출합니다.

추가로 소켓의 종료 방법에는 2가지가 있습니다.

```java
int close(int socket_fd);
int shutdown(int socket_fd, int how_to);
```

📌 **close()** - 두개의 스트림을 동시에 모두 끊기
_close()_은 자신의 소켓 버퍼에 쌓인 데이터와 소켓의 옵션에 따라 다르게 동작한다. 이 뿐만 아니라 _close()_ 함수 호출이 끝나는 시점에 socket 리소스를 반환하는 동작 또한 수행한다.

리소스 반환하는 동작에서 다음과 같은 옵션으로 결정하게 됩니다.
- l_onoff : linger 옵션을 끌것인지 킬것인지 결정
- l_linger : 기다리는 시간의 결정

onoff 값이 0,  소켓 큐의 데이터를 전부 처리하지 않고 상대방에게는 RST 플래그를 세팅해서 보내면서 바로 소켓을 종료합니다.
onoff 값이 1, linger 값에 따라 동작이 달라진다.
* linger값이 0이면 위와 동일하게 동작
* 0이 아닌 값이면 해당 값만큼 소켓 버퍼가 지워지기를 기다린다. 이는 양 쪽 버퍼가 다 비워질 때까지 기다리며, 모두 비워지면 상대에게 FIN을 전송하게 된다.
    * 만약 해당 값내에서 종료하지 못하면 RST 패킷을 세팅해서 보내버리기 때문에 못보낸 TCP 데이터가 있더라도 모두 버린다.
        * ECONNRESET 에러 받게 됨.

그렇기 때문에 _close()_ 함수를 단순히 "shutdown(종료 동작 수행) + 리소스 정리"라고 정의하기엔 무리가 있습니다.

📌 **shutdown(how)** - 하나의 스트림만 끊기

how를 인자로 받으며, SD_SEND(혹은 SD_BOTH)를 인자로 넣을 경우. "더 이상 내가 보낼 데이터는 없다." 란 의미로 FIN 패킷을 상대방에게 전송하게 되어 있습니다.

소켓의 소멸과는 상관이 없습니다.

한번 소켓을 셧다운 했다면, 소켓을 재활용 할 수 없고 새로 생성해야 한다는 뜻입니다. (만들기 나름이겠지만 세션 로그인 테스트를 할때 세션을 재활용 할 생각 말고, 세션을 새로 생성하는게 여러모로 편하다는 뜻이다.)

만약 소켓을 재활용 하고 싶다면 _shutdown()_이 아닌 _DiconnectEx()_ 함수를 활용해야 합니다.

shutdown()참고 사항
* _shutdown()_은 어플리케이션의 Write()/Read()함수가 동작하지 않도록 막는것이라는 점
* 다르게 말하자면 송신의 경우 송신 어플리케이션 버퍼의 데이터를 송신 소켓 버퍼로 복사 할 수 없게 만드는 것이며(Write), 수신 소켓 버퍼의 데이터(Read)는 모두 비워 버리고 입력 관련 함수의 호출을 막는 것
* 송신 소켓 버퍼에 차있는 데이터가 상대쪽으로 넘어가는 것을 막는것은 아님
* _shutdown()_의 호출은 바로 FIN을 상대에게 날림으로 4-way handshake를 유도
* 이런 동작은 half-close라 하여 클라이언가 자신이 보내고 싶은 데이터를 모두 보내고 종료 할 수 있도록 함. (graceful shutdown)

📌 **두 함수의 차이 정리**
① _shutdown()_은 무조건 FIN 패킷을 보내는 반면, _close()_은 자신의 소켓버퍼 상태와 소켓옵션에 따라 RST 패킷을 보낼 수도 있고, FIN 패킷을 보낼 수도 있다.
② _shutdown()_은 함수의 호출을 막는데 반해, _close()_은 소켓 버퍼 자체를 종료 시킨다.
③ _close()_은 socket 리소스의 반환 동작까지 수행한다.

---
## 3. 데이터를 송수신한다
### 프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다
_connect_ 에서 애플리케이션에 제어가 되돌아오면 데이터 송수신 동작에 들어갑니다.

이 동작은 애플리케이션이 _write_를 호출하여 송신데이터를 프로토콜 스택에 건네주고 프로토콜 스택이 송신 동작을 실행합니다.

- 프로토콜 스택은 받은 데이터의 내용에 무엇이 쓰여있는지 알지 못합니다.
- 데이터를 곧바로 송신하지 않고 자체의 버퍼 메모리 영역에 저장하고, 다음 데이터를 기다립니다.
    - 바로 송신하지 않고 데이터를 임시 영역에 담는 이유는, 애플리케이션마다 데이터의 길이나 송신 방식이 다르기 때문

- **MTU**(Maximum Transmission Unit): 패킷 하나로 운반 가능한 데이터의 최대 길이
- **MSS**(Maximum segment size): 헤더를 제외한 하나의 패킷으로 운반 가능한 TCP 데이터의 최대 길이
- 만약 애플리케이션의 송신 속도가 느릴 경우, MSS에 가깝게 데이터를 저장하는데 송신 동작이 지연이 생길 수 있습니다.
    - 따라서 버퍼에 데이터가 모이지 않아도 프로토콜 스택 내부의 타이머를 통해 일정 시간 이상을 경과할 때마다 송신이 가능하다.

위 두가지 요소는 서로 상반된다. 따라서 두가지를 절충해서 송신 동작을 실행해야합니다.


### ACK 번호를 사용하여 패킷이 도착했는지 확인한다.
TCP 담당 부분은 데이터를 분할할 때 조각이 몇 번째 바이트에 해당하는지를 세어둡니다. 그리고 이를 TCP 헤더의 시퀀스 번호라는 항목에 기록합니다. 

**실제 동작 과정**
- 접속 동작을 실행할 때 클라이언트에서 서버로 보내는 데이터에 관한 시퀀스 번호의 초기값을 서버에 통지
- 서버에서 산출한 ACK 번호, 서버에서 클라이언트로 보내는 데이터에 관한 시퀀스 번호의 초기값 을 포함하여 응답
- 클라이언트에서 서버에서 받은 시퀀스 번호로 부터 ACK 번호를 산출하여 서버에 반송
- 클라이언트에서 서버로 데이터와 시퀀스 번호 를 송신
- 서버는 ACK를 응답

### 패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다.
- ACK 번호가 돌아오기를 기다리는 시간을 **타임아웃 값**이라고 한다.
- ACK 번호의 반송이 지연되도록 하는 사태는 혼잡이 원인인 경우가 많으므로 거기에 헛된 패킷을 보내면 혼잡을 악화시킬 우려가 있습니다. 그렇다고 대기 시간이 길게 되면 패킷을 다시 보내는 동작이 지연되어 속도 저하의 원인이 됩니다
- 따라서 타임아웃 값은 다양한 요건을 고려해서 결정해야 한다.
- TCP는 타임아웃 값을 ACK 번호가 돌아오는 시간을 기준으로 동적으로 변경한다.


### 윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다.
한 개의 패킷을 보내고 ACK 번호를 기다리는 방법은 단순하지만 시간낭비일 수 있습니다. 
이러한 낭비를 줄이기 위해 TCP는 윈도우 제어라는 방식에 따라 송신과 ACK 번호 통지 동작을 실행합니다.

윈도우란?
| 전송,수신 스테이션 양쪽에서 만들어진 버퍼(Buffer)의 크기다.

윈도우 제어란?
| 한 개의 패킷을 보낸후 ACK 번호를 기다리지 않고 차례대로 연속해서 복수의 패킷을 보내는 방법입니다.

주의 사항
* 수신측의 능력을 초과하여 패킷을 보내는 사태가 일어날 수도 있다는 것입니다.
    * 패킷을 버퍼 메모리에 일시 보관하였다가 연결하여 원래 데이터를 복원한 후 애플리케이션에 건네주기 위함
* 수신측에서 애플리케이션에 건네주는 속도보다 빠른 속도로 데이터가 도착하면 버퍼 메모리가 넘치게 됩니다.

이를 방지하기 위해서는 수신측에서 송신측에 수신 가능한 데이터 양을 통지하고 이 양을 초과하지 않도록 송신 동작을 실행해야됩니다

해결 법
- 수신측에서 송신측에 수신 가능한 데이터 양을 통지합니다. - TCP 헤더의 **윈도우 필드**
- 수신 가능한 데이터 양의 최대값 -  **윈도우 사이즈**

### ACK 번호와 윈도우를 합승한다.
- 송수신 동작에 있어 윈도우와 ACK 번호를 통지하게 되는데, 이를 각각 통지하면 송신하는 패킷이 불필요하게 많아져 효율성이 저하됩니다.
- 수신측은 ACK번호나 윈도우를 통지할 때 소켓을 바로 보내지 않고 잠시 기다리는데 다음 통지 동작이 일어나면 한 개의 패킷으로 묶어서 보냅니다.
- ACK번호나 윈도우 모두 연속해서 일어난 경우에 최후의 것만 통지합니다.

### HTTP 응답 메세지를 수신한다
송신측(클라이언트) 는 HTTP 리퀘스트 메시지를 보내고 웹 서버에서 응답 메시지가 돌아오기를 기다리고, 수신합니다.

이를 위해 애플리케이션은 _read_ 프로그램을 호출합니다.

수신작업은 위에서 설명한 것과 동일하게 동작한다.
- TCP 헤더의 내용을 조사하여 누락된 데이터를 확인하고, 문제 없을시 ACK 번호 응답합니다.
- 데이터 조각을 수신 버퍼에 일시 보관하고 조각을 원래 데이터로 복원한 후 애플리케이션 메모리 영역으로 전달합니다.
- 데이터를 건네주고 나서 타이밍을 가늠하여 윈도우를 송신측에 통지합니다.

## 4. 서버에서 연결을 끊어 소켓을 말소한다.
### 데이터 보내기를 완료했을 때 연결을 끊는다
- 애플리케이션이 **데이터를 전부 송신**하면 연결 끊기 단계로 들어는데, 어디에서 송수신 동작이 끝나는지는 애플리케이션에 따라 다르다.
- **서버**
    - 서버측 애플리케이션이 Socket 라이브러리의 close를 호출한다.
    - 서버측 프로토콜 스택이 TCP 헤더에 FIN 1을 설정하고 IP 담당 부분에 의뢰하여 클라이언트에게 송신한다.
- **클라이언트**
    - 서버에서 FIN 1로 설정된 TCP 헤더가 도착하면 클라이트언트의 프로토콜 스택이 서버가 연결 끊기(TIME_WAIT)에 들어간 것을 알게 된다.
    - ACK 번호를 서버에 반송하고 애플리케이션이 데이터를 가지러 오길 기다린다.
    - 애플리케이션이 read로 데이터를 가지러 오면, 데이터를 건네지 않고 서버에서 보낸 데이터를 전부 수신 완료했다는 것을 클라이언트 애플리케이션에게 알린다.
    - 서버에서 보낸 데이터를 모두 수신했으니, 클라이언트도 close를 호출해 연결 끊기 동작으로 들어간다.
    - 클라이언트 프로토콜도 서버측과 마찬가지로 FIN에 1을 설정한 TCP 헤더를 만들고 서버에 송신, 서버에서 ACK 번호가 돌아오면 연결이 끝난다.

### 소켓을 말소한다
- 연결을 끊고 소켓이 당장 필요 없지만, 소켓을 바로 말소하진 않고 오동작을 막기 위해 잠시 대기 후에 말소시킨다.

* 오동작의 예시
클라이언트가 FIN을 송신하고 서버가 ACK, FIN을 송신하고 클라이언트가 소켓을 말소한다면 거기에 기록되어 있던 제어 정보가 없어지므로 소켓에 할당되어 있던 포트 번호도 몇 번인지 알 수 없게 됩니다.

이 시점에 다른 애플리케이션이 소켓을 작성하면 같은 포트 번호가 할당될 수 있습니다.
만약, 이 상태에서 서버가 다시 보낸 FIN이 도착하면 어떻게 될까요? 

## 5. IP와 이더넷의 패킷 송수신 동작

#### #### TCP/IP 에서 패킷 구조

두 가지 중계 장치가 있습니다. 서브넷을 관리하는 ‘허브’와 IP를 담당하는 ‘라우터’ 입니다.

각각 다음 역할을 합니다.

- 라우터가 목적지를 확인하여 다음 라우터를 찾는다.
    - IP가 다음 목적지를 확인하여 다음 IP 중계 장치를 찾는다.
- 허브가 서브넷 안에서 패킷을 운반해 다음 라우터에 도착하도록 한다.
    - 서브넷 안의 이더넷이 라우터까지 패킷을 운반한다.

위 역할을 수행하기 위해서 패킷에 다음 두 헤더가 붙어 있습니다.

1. MAC 헤더 (이더넷용 헤더)
2. IP 헤더 (IP용 헤더)

- 패킷 운반 흐름은 다음과 같습니다.
    - 먼저 클라이언트가 TCP 헤더 + 데이터를 이어붙이고 목적 IP 주소에 맞는 다음 라우터를 조사한다.
    - 다음 라우터가 정해지면 해당 라우터에 대한 MAC 주소를 조사하고 패킷의 MAC 헤더에 추가한다.
    - 이더넷에게 해당 라우터로 패킷을 전송하도록 의뢰하여 패킷을 송신한다.
    - 이더넷에 의해 허브에 도착한다. 허브에서 이더넷 표와 헤더 정보를 결합해서 다음 라우터로 중계한다.
        - 만일 허브가 여러개라면 여러 허브를 순차적으로 경우한다.
    - 다음 라우터에 도착해서 IP용 표를 통해 다음 라우터를 조사하여 MAC 주소를 헤더가 기록한다.
        - 동일하게 허브를 경유하여 다음 라우터에 도착한다. 수신처에 도착할 때까지 반복한다.


- 이더넷 대신 무선 LAN, ADSL 등으로 대체될 수 있습니다.
    - **IP의 의뢰를 받아서 패킷을 운반할 수 있는 것이면 됩니다.**

### 2. 패킷 송수신 동작의 개요

IP 담당은 패킷을 송출하고 실제 패킷의 운반은 네트워크 기기인 허브 및 라우터가 수행합니다.

- TCP 담당에서 TCP 헤더와 데이터가 붙은 채로 IP 담당에게 넘어온다.
- IP 담당은 넘어온 패킷을 들여다보지 않고 단지 헤더를 추가한다.
    - IP 헤더와 MAC 헤더를 추가한다.
- IP 헤더: 목적지를 나타내는 제어정보
- MAC 헤더: LAN을 사용해서 가까운 라우터까지 패킷을 운반할 때 사용할 제어정보
- 이렇게 만들어진 패킷을 네트워크용 하드웨어(이더넷 or 무선 LAN - **LAN 어댑터**로 통칭)에 건네준다.
    - 0과 1로 이루어진 디지털 데이터의 모습이다.
    - LAN 어댑터는 전기나 빛의 신호로 바꾸어 케이블로 송출한다.
    - 이후 허브나 라우터 등의 중계 장치에 도착한다.
- TCP 담당부분의 데이터 송수신 동작의 단계와 상관없이 IP 패킷은 모두 같다
    - 제어 패킷이든, 데이터 패킷이든 역할에 상관없이 같다
- 의뢰받은 내용물을 패킷의 모습으로 만들어 상대에게 송신하거나 전달한 패킷을 수신만 한다

### 3. 수신처 IP주소를 기록한 IP 헤더를 만든다

- 수신처 IP주소 : TCP 담당부분에서 통지된 통신 상대의 IP 주소를 그대로 설정
- 송신처 IP주소 : LAN 어댑터에 의해 결정

### 4. 이더넷용 MAC 헤더를 만든다

MAC 헤더는 이더넷이 사용한다.

- 수신처 MAC 주소, 송신처 MAC주소, 이더 타입(사용하는 프로토콜 종류 ARP, IP, IPv6 등등)

#### MAC 주소 알아보기

- MAC 주소는 48비트이다.
- 이더타입에 프로토콜 번호를 기입한다.
    - 이더넷의 경우 IP혹은 ARP이다.
- 송신처 MAC주소에 LAN 어댑터의 MAC 주소를 설정한다.
- 수신처의 MAC 주소를 조사해서 설정한다.
    - 경로표의 Gateway가 패킷을 건내줄 대상이다.
    - 이 IP 주소로 MAC 주소를 조사한다.

### 5. ARP로 수신처 라우터의 MAC 주소를 조사한다

- 이더넷에 브로드캐스를 통해 연결된 전원에게 xx IP 주소(게이트웨이의 IP 주소)를 물어봐서 MAC주소를 획득한다.
    - 상대가 자신과 같은 네트워크라면 이렇게 MAC주소를 알 수 있다. (Gateway가 라우터 IP 주소인 경우 라우터가 응답한다)
    - 해당하지 않는 기기는 브로드캐스트 메세지를 무시한다.
    - ARP 응답이 없다면 패킷 송신 동작이 실패한다.
    - 매번 ARP 패킷을 보내는 것은 어렵기 때문에 메모리에 ARP 캐시 데이터를 저장한다.
        - `arp -a` 를 통해 ARP 캐시데이터를 확인
        - `arp -d` 를 통해 캐시 데이터 삭제
        - 몇 분이 지나면 캐시 데이터를 삭제한다 → IP가 더이상 유효하지 않을수 있기 때문이다.
    - MAC 헤더를 붙이면 LAN 어댑터가 패킷을 그대로 송수신할 수 있다.
    - MAC주소는 `:` 또는 `-`로 구분하며 총 48피트이고 8비트씩 16진수로 나타낸다.

### 6. 이더넷의 기본

- **이더넷은 컴퓨터가 여러 컴퓨터와 적은 비용으로 자유롭게 통신하기 위한 통신 기술이다.**
- 원형은 하나의 케이블에 여러 컴퓨터가 연결이 되어 있어서 케이블로 전체에게 신호가 가고 MAC헤더를 통해 수신처를 판단하여 다른 대상들을 해당 패킷을 폐기하고 대상 컴퓨터만 패킷을 받게 되는 구조이다.
- 케이블 → 리피터 허브 → 스위칭 허브(현재 모습)으로 변화했다.
    - 전원에게 신호를 보내는 것이 아니라 MAC 주소로 알아낸 원하는 상대에게만 신호가 흐른다.
- 패킷의 내용물은 보지 않고 이더넷의 송수신 동작은 TCP 동작 단계에 상관 없이 모든 것에 공통이다

### 7. IP 패킷을 전기나 빛의 신호로 변환하여 송신한다

- LAN 어댑터가 디지털 데이터를 전기나 빛의 신호로 변환하여 네트워크 케이블에 송출한다.
- LAN 어댑터를 제어하는 LAN 드라이버라는 소프트웨어가 필요하다.

### 8. 패킷에 3개 제어용 데이터를 추가한다

- 프리앰블, 스타트 프레임 딜리미터, 프레임 체크 시퀀스(오류 검출용 데이터)를 추가한다.
- 프리앰플로 클록신호의 타이밍을 잡는다.
- 스타트 프레임 딜리미터로 패킷 신호 시작을 나타낸다.
- FCS로 오류를 검출한다.

### 9. 허브를 향해 패킷을 송신한다

- 리피터 허브의 반이중 모드 & 스위치 허브의 전이중 모드가 있다.
- 반이중 모드
    - 케이블에 다른 송신 동작이 흐르고 있으면 대기했다가 송신 동작을 시작한다.
    - 동시에 신호가 흐르면 충돌이 나며 재밍 신호를 보내고 송신 동작을 멈추고 잠시 후 다시 시작한다.
- 전이중 모드는 충돌이 일어나지 않는다.

### 10. 돌아온 패킷을 받는다

- 리피터 허브에서는 한대에서 송신해도 전체에 신호가 간다. 이것을 모두 수신 신호로 받는다.
- 프리앰블로 타이밍일 계산하고 스타트 프레임 딜리미터가 나오면 그 다음 비트부터 패킷으로 판단해 디지털 데이터로 변환한다. 최후에 FCS를 검사하여 오류가 있다면 폐기한다.
- 오류가 없다면 MAC헤더 수신처와 MAC 주소를 조사하여 자신의 것이면 수신하여 버퍼 메모리에 저장하고 아니라면 패킷을 폐기한다.
- 자신의 것이라서 패킷을 수신하면 **interrupt 인터럽트**로 컴퓨터에 통지한다.

### 11. 서버의 응답 패킷을 IP에서 TCP로 넘긴다

- 웹서버에서 패킷이 돌아오면 (LAN 어댑터가 프로토콜 번호를 확인해 TCP/IP 프로토콜 스택으로 전송함) 프로토콜 스택의 IP 담당 부분에 넘겨진다.
    - IP 헤더를 조사해 수신처 IP주소를 조사하여 LAN 어댑터와 일치하는지 확인하고 패킷을 수신한다.
    - 만일 자신에게 온 패킷이 아니라면 IP 담당 부분이 **ICMP 메세지로 통신 상대에게 오류를 통지**한다.
        - 여러 메세지 종류가 있다.
- 만일 패킷이 fragment로 분할된 것이면 IP 담당은 패킷을 복원한다.
    - IP 헤더의 flag로 분할여부를 확인할 수 있다.
    - ID 정보로 같은 패킷임을 확인할 수 있다.
    - fragment offset으로 패킷 위치를 알 수 있다.
    - 패킷을 복원하는 동작 = reassembling 리어셈블링이라고 한다.
- 리어셈블링이 끝나면 패킷을 TCP 담당 부분에 넘긴다.

## 6. UDP 프로토콜을 이용한 송수신동작

### 1. 수정송신이 필요없는 데이터 송신은 UDP가 효율적이다.

- ex. DNS 서버에서 IP 주소를 조회할 때
- 만일 데이터를 보내서 수신응답이 오지 않으면 패킷을 전부 다 보내는 간단한 방법이 있다.
    - 하지만 그것을 비효율적이니 TCP가 누락된 부분만 보내기 위해서 복잡한 구조인 것이다.
- 패킷이 하나라면 복잡하게 생각하지 않고 회신이 오지 않으면 다시 보내면 된다.

### 2. 제어용 짧은 데이터

- DNS 조회 같은 경우 패킷 1개로 가능한 짧은 요청이기 때문에 UDP를 사용한다.
- 접속이나 연결 끊기 단계가 없이 송신 데이터에 UDP 헤더만 추가하여 바로 IP 담당에 의뢰하여 송신한다.
- 만일 오류가 생기면 송신측에서 회답이 오지 않으므로 데이터를 한번 더 보낸다.

### 3. 음성 및 동영상 데이터

- 음성이나 영상 데이터는 결정된 시간안에 데이터를 건네주어야 한다
- TCP의 경우 시간이 더 걸리므로 재생 타이밍이 맞지 않을 수 있다.











